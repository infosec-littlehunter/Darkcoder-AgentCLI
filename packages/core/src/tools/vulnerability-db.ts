/**
 * @license
 * Copyright 2025 DarkCoder
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * Vulnerability Database Tool
 *
 * Query CVE/NVD database, Exploit-DB, and check for public PoCs.
 * Maps CVEs to affected products and versions.
 */

import { apiKeyManager } from '../config/api-keys.js';
import { ToolErrorType } from './tool-error.js';
import { ToolNames, ToolDisplayNames } from './tool-names.js';
import type { ToolInvocation, ToolResult } from './tools.js';
import { BaseDeclarativeTool, BaseToolInvocation, Kind } from './tools.js';

/**
 * Operation modes for the vulnerability database tool
 */
export type VulnDbOperation =
  | 'cve' // Get CVE details
  | 'search' // Search for vulnerabilities
  | 'exploit' // Search Exploit-DB
  | 'poc' // Check for public PoCs
  | 'product' // Search by product/vendor
  | 'recent' // Get recent CVEs
  | 'severity' // Search by severity
  | 'cwe'; // Get CWE details

/**
 * CVE data structure
 */
export interface CVEData {
  id: string;
  description: string;
  severity: string;
  cvssScore?: number;
  cvssVector?: string;
  cwe?: string[];
  references?: string[];
  affectedProducts?: AffectedProduct[];
  publishedDate?: string;
  lastModifiedDate?: string;
  exploitAvailable?: boolean;
  pocAvailable?: boolean;
}

export interface AffectedProduct {
  vendor: string;
  product: string;
  versions: string[];
}

export interface ExploitData {
  id: string;
  title: string;
  platform: string;
  type: string;
  author: string;
  date: string;
  url: string;
  cve?: string;
  verified?: boolean;
}

/**
 * Parameters for the Vulnerability Database tool
 */
export interface VulnDbParams {
  operation: VulnDbOperation;
  cveId?: string;
  query?: string;
  product?: string;
  vendor?: string;
  severity?: 'low' | 'medium' | 'high' | 'critical';
  cweId?: string;
  year?: number;
  limit?: number;
  includeExploits?: boolean;
}

/**
 * Vulnerability Database Tool Invocation
 */
class VulnDbInvocation extends BaseToolInvocation<VulnDbParams, ToolResult> {
  constructor(params: VulnDbParams) {
    super(params);
  }

  getDescription(): string {
    const { operation, cveId, query, product } = this.params;
    switch (operation) {
      case 'cve':
        return `Looking up CVE: ${cveId}`;
      case 'search':
        return `Searching vulnerabilities: ${query}`;
      case 'exploit':
        return `Searching exploits: ${query || cveId}`;
      case 'poc':
        return `Checking PoCs for: ${cveId}`;
      case 'product':
        return `Finding vulnerabilities for: ${product}`;
      case 'recent':
        return 'Getting recent CVEs';
      case 'severity':
        return `Finding ${this.params.severity} severity CVEs`;
      case 'cwe':
        return `Looking up CWE: ${this.params.cweId}`;
      default:
        return 'Vulnerability database query';
    }
  }

  async execute(): Promise<ToolResult> {
    await apiKeyManager.initialize();

    const { operation } = this.params;

    switch (operation) {
      case 'cve':
        return this.getCVEDetails();
      case 'search':
        return this.searchVulnerabilities();
      case 'exploit':
        return this.searchExploits();
      case 'poc':
        return this.checkPoCs();
      case 'product':
        return this.searchByProduct();
      case 'recent':
        return this.getRecentCVEs();
      case 'severity':
        return this.searchBySeverity();
      case 'cwe':
        return this.getCWEDetails();
      default:
        return {
          llmContent: `Unknown operation: ${operation}`,
          returnDisplay: 'Unknown operation',
          error: {
            message: `Unknown operation: ${operation}`,
            type: ToolErrorType.INVALID_TOOL_PARAMS,
          },
        };
    }
  }

  /**
   * Get detailed CVE information
   */
  private async getCVEDetails(): Promise<ToolResult> {
    const { cveId, includeExploits = true } = this.params;

    if (!cveId) {
      return {
        llmContent: 'CVE ID is required',
        returnDisplay: 'Missing CVE ID',
        error: {
          message: 'CVE ID is required',
          type: ToolErrorType.INVALID_TOOL_PARAMS,
        },
      };
    }

    const normalizedCveId = cveId.toUpperCase();
    if (!normalizedCveId.match(/^CVE-\d{4}-\d{4,}$/)) {
      return {
        llmContent: `Invalid CVE ID format: ${cveId}. Expected format: CVE-YYYY-NNNNN`,
        returnDisplay: 'Invalid CVE ID',
        error: {
          message: 'Invalid CVE ID format',
          type: ToolErrorType.INVALID_TOOL_PARAMS,
        },
      };
    }

    try {
      // Query NVD API
      const cveData = await this.fetchNVDData(normalizedCveId);

      // Check for exploits if requested
      let exploits: ExploitData[] = [];
      if (includeExploits) {
        exploits = await this.fetchExploitDBData(normalizedCveId);
      }

      // Check for PoCs
      const pocs = await this.checkGitHubPoCs(normalizedCveId);

      return this.formatCVEResult(cveData, exploits, pocs);
    } catch {
      // Return cached/known CVE data as fallback
      return this.getKnownCVEData(normalizedCveId);
    }
  }

  /**
   * Fetch CVE data from NVD
   */
  private async fetchNVDData(cveId: string): Promise<CVEData> {
    const nvdApiKey = apiKeyManager.getApiKey('nvd');
    const headers: Record<string, string> = {
      Accept: 'application/json',
    };

    if (nvdApiKey) {
      headers['apiKey'] = nvdApiKey;
    }

    const response = await fetch(
      `https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=${cveId}`,
      { headers },
    );

    if (!response.ok) {
      throw new Error(`NVD API error: ${response.status}`);
    }

    const data = (await response.json()) as {
      vulnerabilities?: Array<{
        cve?: {
          id?: string;
          descriptions?: Array<{ lang?: string; value?: string }>;
          metrics?: {
            cvssMetricV31?: Array<{
              cvssData?: {
                baseScore?: number;
                baseSeverity?: string;
                vectorString?: string;
              };
            }>;
            cvssMetricV2?: Array<{
              cvssData?: {
                baseScore?: number;
                vectorString?: string;
              };
            }>;
          };
          weaknesses?: Array<{
            description?: Array<{ value?: string }>;
          }>;
          references?: Array<{ url?: string }>;
          configurations?: Array<{
            nodes?: Array<{
              cpeMatch?: Array<{
                criteria?: string;
                vulnerable?: boolean;
              }>;
            }>;
          }>;
          published?: string;
          lastModified?: string;
        };
      }>;
    };

    const vuln = data.vulnerabilities?.[0]?.cve;
    if (!vuln) {
      throw new Error('CVE not found');
    }

    const cvss31 = vuln.metrics?.cvssMetricV31?.[0]?.cvssData;
    const cvss2 = vuln.metrics?.cvssMetricV2?.[0]?.cvssData;

    return {
      id: vuln.id || cveId,
      description:
        vuln.descriptions?.find((d) => d.lang === 'en')?.value ||
        'No description available',
      severity:
        cvss31?.baseSeverity ||
        this.getSeverityFromScore(cvss31?.baseScore || cvss2?.baseScore),
      cvssScore: cvss31?.baseScore || cvss2?.baseScore,
      cvssVector: cvss31?.vectorString || cvss2?.vectorString,
      cwe: vuln.weaknesses
        ?.flatMap((w) => w.description?.map((d) => d.value) || [])
        .filter(Boolean) as string[],
      references: vuln.references
        ?.map((r) => r.url)
        .filter(Boolean) as string[],
      affectedProducts: this.parseAffectedProducts(vuln.configurations),
      publishedDate: vuln.published,
      lastModifiedDate: vuln.lastModified,
    };
  }

  /**
   * Parse affected products from CPE configurations
   */
  private parseAffectedProducts(
    configurations?: Array<{
      nodes?: Array<{
        cpeMatch?: Array<{
          criteria?: string;
          vulnerable?: boolean;
        }>;
      }>;
    }>,
  ): AffectedProduct[] {
    const products = new Map<string, AffectedProduct>();

    for (const config of configurations || []) {
      for (const node of config.nodes || []) {
        for (const match of node.cpeMatch || []) {
          if (!match.vulnerable || !match.criteria) continue;

          // Parse CPE string: cpe:2.3:a:vendor:product:version:...
          const parts = match.criteria.split(':');
          if (parts.length >= 5) {
            const vendor = parts[3];
            const product = parts[4];
            const version = parts[5] || '*';

            const key = `${vendor}:${product}`;
            if (!products.has(key)) {
              products.set(key, { vendor, product, versions: [] });
            }
            const p = products.get(key)!;
            if (!p.versions.includes(version)) {
              p.versions.push(version);
            }
          }
        }
      }
    }

    return Array.from(products.values());
  }

  /**
   * Get severity from CVSS score
   */
  private getSeverityFromScore(score?: number): string {
    if (!score) return 'UNKNOWN';
    if (score >= 9.0) return 'CRITICAL';
    if (score >= 7.0) return 'HIGH';
    if (score >= 4.0) return 'MEDIUM';
    return 'LOW';
  }

  /**
   * Fetch exploit data from Exploit-DB
   */
  private async fetchExploitDBData(cveId: string): Promise<ExploitData[]> {
    try {
      // Use ExploitDB search API
      const response = await fetch(
        `https://www.exploit-db.com/search?cve=${cveId.replace('CVE-', '')}`,
        {
          headers: {
            Accept: 'application/json',
            'User-Agent': 'DarkCoder-CLI/1.0',
          },
        },
      );

      if (!response.ok) {
        return this.getKnownExploits(cveId);
      }

      const data = (await response.json()) as {
        data?: Array<{
          id?: string;
          description?: string;
          platform?: { platform?: string };
          type?: { name?: string };
          author?: { name?: string };
          date?: string;
          verified?: string;
        }>;
      };

      return (data.data || []).map((e) => ({
        id: e.id || '',
        title: e.description || '',
        platform: e.platform?.platform || 'Multiple',
        type: e.type?.name || 'Unknown',
        author: e.author?.name || 'Unknown',
        date: e.date || '',
        url: `https://www.exploit-db.com/exploits/${e.id}`,
        cve: cveId,
        verified: e.verified === '1',
      }));
    } catch {
      return this.getKnownExploits(cveId);
    }
  }

  /**
   * Get known exploits for common CVEs
   */
  private getKnownExploits(cveId: string): ExploitData[] {
    const knownExploits: Record<string, ExploitData[]> = {
      'CVE-2021-44228': [
        {
          id: '50592',
          title: 'Apache Log4j 2 - Remote Code Execution (RCE)',
          platform: 'Multiple',
          type: 'Remote',
          author: 'Various',
          date: '2021-12-10',
          url: 'https://www.exploit-db.com/exploits/50592',
          cve: 'CVE-2021-44228',
          verified: true,
        },
      ],
      'CVE-2017-0144': [
        {
          id: '42315',
          title: 'Microsoft Windows - SMB Remote Code Execution (EternalBlue)',
          platform: 'Windows',
          type: 'Remote',
          author: 'Shadow Brokers',
          date: '2017-05-17',
          url: 'https://www.exploit-db.com/exploits/42315',
          cve: 'CVE-2017-0144',
          verified: true,
        },
      ],
      'CVE-2021-34527': [
        {
          id: '50055',
          title:
            'Windows Print Spooler - Remote Code Execution (PrintNightmare)',
          platform: 'Windows',
          type: 'Remote',
          author: 'Various',
          date: '2021-07-01',
          url: 'https://www.exploit-db.com/exploits/50055',
          cve: 'CVE-2021-34527',
          verified: true,
        },
      ],
    };

    return knownExploits[cveId] || [];
  }

  /**
   * Check for PoCs on GitHub
   */
  private async checkGitHubPoCs(
    cveId: string,
  ): Promise<Array<{ name: string; url: string; stars: number }>> {
    try {
      const response = await fetch(
        `https://api.github.com/search/repositories?q=${cveId}+poc+OR+exploit&sort=stars&per_page=5`,
        {
          headers: {
            Accept: 'application/vnd.github.v3+json',
            'User-Agent': 'DarkCoder-CLI/1.0',
          },
        },
      );

      if (!response.ok) {
        return [];
      }

      const data = (await response.json()) as {
        items?: Array<{
          full_name?: string;
          html_url?: string;
          stargazers_count?: number;
        }>;
      };

      return (data.items || []).map((repo) => ({
        name: repo.full_name || '',
        url: repo.html_url || '',
        stars: repo.stargazers_count || 0,
      }));
    } catch {
      return [];
    }
  }

  /**
   * Format CVE result
   */
  private formatCVEResult(
    cve: CVEData,
    exploits: ExploitData[],
    pocs: Array<{ name: string; url: string; stars: number }>,
  ): ToolResult {
    const severityEmoji = {
      CRITICAL: 'ðŸ”´',
      HIGH: 'ðŸŸ ',
      MEDIUM: 'ðŸŸ¡',
      LOW: 'ðŸŸ¢',
      UNKNOWN: 'âšª',
    };

    const output: string[] = [
      `# ${cve.id}`,
      '',
      `**Severity:** ${severityEmoji[cve.severity as keyof typeof severityEmoji] || 'âšª'} ${cve.severity}`,
      cve.cvssScore ? `**CVSS Score:** ${cve.cvssScore}/10` : '',
      cve.cvssVector ? `**CVSS Vector:** \`${cve.cvssVector}\`` : '',
      '',
      '## Description',
      '',
      cve.description,
      '',
    ];

    if (cve.cwe && cve.cwe.length > 0) {
      output.push('## Weakness (CWE)');
      output.push('');
      for (const cwe of cve.cwe) {
        output.push(`- ${cwe}`);
      }
      output.push('');
    }

    if (cve.affectedProducts && cve.affectedProducts.length > 0) {
      output.push('## Affected Products');
      output.push('');
      output.push('| Vendor | Product | Versions |');
      output.push('|--------|---------|----------|');
      for (const product of cve.affectedProducts.slice(0, 10)) {
        output.push(
          `| ${product.vendor} | ${product.product} | ${product.versions.slice(0, 3).join(', ')} |`,
        );
      }
      output.push('');
    }

    if (exploits.length > 0) {
      output.push('## ðŸ”“ Available Exploits');
      output.push('');
      for (const exploit of exploits) {
        output.push(`### ${exploit.title}`);
        output.push(`- **Platform:** ${exploit.platform}`);
        output.push(`- **Type:** ${exploit.type}`);
        output.push(`- **Author:** ${exploit.author}`);
        output.push(`- **Verified:** ${exploit.verified ? 'âœ… Yes' : 'âŒ No'}`);
        output.push(`- **URL:** ${exploit.url}`);
        output.push('');
      }
    }

    if (pocs.length > 0) {
      output.push('## ðŸ§ª GitHub PoCs');
      output.push('');
      for (const poc of pocs) {
        output.push(`- [${poc.name}](${poc.url}) â­ ${poc.stars}`);
      }
      output.push('');
    }

    if (cve.references && cve.references.length > 0) {
      output.push('## References');
      output.push('');
      for (const ref of cve.references.slice(0, 10)) {
        output.push(`- ${ref}`);
      }
      output.push('');
    }

    output.push('## Timeline');
    output.push('');
    if (cve.publishedDate) {
      output.push(
        `- **Published:** ${new Date(cve.publishedDate).toLocaleDateString()}`,
      );
    }
    if (cve.lastModifiedDate) {
      output.push(
        `- **Last Modified:** ${new Date(cve.lastModifiedDate).toLocaleDateString()}`,
      );
    }

    return {
      llmContent: output.filter(Boolean).join('\n'),
      returnDisplay: `${cve.id} - ${cve.severity}`,
    };
  }

  /**
   * Get known CVE data for famous vulnerabilities
   */
  private getKnownCVEData(cveId: string): ToolResult {
    const knownCVEs: Record<string, CVEData> = {
      'CVE-2021-44228': {
        id: 'CVE-2021-44228',
        description:
          'Apache Log4j2 2.0-beta9 through 2.15.0 (excluding security releases 2.12.2, 2.12.3, and 2.3.1) JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints. An attacker who can control log messages or log message parameters can execute arbitrary code loaded from LDAP servers when message lookup substitution is enabled.',
        severity: 'CRITICAL',
        cvssScore: 10.0,
        cvssVector: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H',
        cwe: ['CWE-502', 'CWE-400', 'CWE-20'],
        affectedProducts: [
          {
            vendor: 'apache',
            product: 'log4j',
            versions: ['2.0-beta9', '2.15.0'],
          },
        ],
        publishedDate: '2021-12-10',
        exploitAvailable: true,
        pocAvailable: true,
      },
      'CVE-2017-0144': {
        id: 'CVE-2017-0144',
        description:
          'The SMBv1 server in Microsoft Windows allows remote attackers to execute arbitrary code via crafted packets, aka "Windows SMB Remote Code Execution Vulnerability." This vulnerability is also known as EternalBlue.',
        severity: 'CRITICAL',
        cvssScore: 8.1,
        cvssVector: 'CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H',
        cwe: ['CWE-119'],
        affectedProducts: [
          {
            vendor: 'microsoft',
            product: 'windows',
            versions: [
              '7',
              '8.1',
              '10',
              'Server 2008',
              'Server 2012',
              'Server 2016',
            ],
          },
        ],
        publishedDate: '2017-03-16',
        exploitAvailable: true,
        pocAvailable: true,
      },
      'CVE-2021-34527': {
        id: 'CVE-2021-34527',
        description:
          'Windows Print Spooler Remote Code Execution Vulnerability, also known as PrintNightmare. A remote code execution vulnerability exists when the Windows Print Spooler service improperly performs privileged file operations.',
        severity: 'HIGH',
        cvssScore: 8.8,
        cvssVector: 'CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H',
        cwe: ['CWE-269'],
        affectedProducts: [
          {
            vendor: 'microsoft',
            product: 'windows',
            versions: [
              '7',
              '8.1',
              '10',
              'Server 2008',
              'Server 2012',
              'Server 2016',
              'Server 2019',
            ],
          },
        ],
        publishedDate: '2021-07-02',
        exploitAvailable: true,
        pocAvailable: true,
      },
      'CVE-2023-44487': {
        id: 'CVE-2023-44487',
        description:
          'The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023. Also known as Rapid Reset Attack.',
        severity: 'HIGH',
        cvssScore: 7.5,
        cvssVector: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H',
        cwe: ['CWE-400'],
        affectedProducts: [
          {
            vendor: 'multiple',
            product: 'http2_implementations',
            versions: ['*'],
          },
        ],
        publishedDate: '2023-10-10',
        exploitAvailable: true,
        pocAvailable: true,
      },
      'CVE-2024-3094': {
        id: 'CVE-2024-3094',
        description:
          'Malicious code was discovered in the upstream tarballs of xz, starting with version 5.6.0. Through a series of complex obfuscations, the liblzma build process extracts a prebuilt object file from a disguised test file existing in the source code, which is then used to modify specific functions in the liblzma code.',
        severity: 'CRITICAL',
        cvssScore: 10.0,
        cvssVector: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H',
        cwe: ['CWE-506'],
        affectedProducts: [
          { vendor: 'tukaani', product: 'xz', versions: ['5.6.0', '5.6.1'] },
        ],
        publishedDate: '2024-03-29',
        exploitAvailable: true,
        pocAvailable: true,
      },
    };

    const cve = knownCVEs[cveId];
    if (cve) {
      const exploits = this.getKnownExploits(cveId);
      return this.formatCVEResult(cve, exploits, []);
    }

    return {
      llmContent: `CVE ${cveId} not found in local cache. Unable to reach NVD API. Try again later or check the CVE ID.`,
      returnDisplay: `CVE not found: ${cveId}`,
      error: {
        message: `CVE not found: ${cveId}`,
        type: ToolErrorType.EXECUTION_FAILED,
      },
    };
  }

  /**
   * Search vulnerabilities by keyword
   */
  private async searchVulnerabilities(): Promise<ToolResult> {
    const { query, limit = 10, severity } = this.params;

    if (!query) {
      return {
        llmContent: 'Search query is required',
        returnDisplay: 'Missing query',
        error: {
          message: 'Search query is required',
          type: ToolErrorType.INVALID_TOOL_PARAMS,
        },
      };
    }

    try {
      let url = `https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=${encodeURIComponent(query)}&resultsPerPage=${limit}`;

      if (severity) {
        url += `&cvssV3Severity=${severity.toUpperCase()}`;
      }

      const nvdApiKey = apiKeyManager.getApiKey('nvd');
      const headers: Record<string, string> = { Accept: 'application/json' };
      if (nvdApiKey) {
        headers['apiKey'] = nvdApiKey;
      }

      const response = await fetch(url, { headers });

      if (!response.ok) {
        throw new Error(`NVD API error: ${response.status}`);
      }

      const data = (await response.json()) as {
        totalResults?: number;
        vulnerabilities?: Array<{
          cve?: {
            id?: string;
            descriptions?: Array<{ lang?: string; value?: string }>;
            metrics?: {
              cvssMetricV31?: Array<{
                cvssData?: {
                  baseScore?: number;
                  baseSeverity?: string;
                };
              }>;
            };
            published?: string;
          };
        }>;
      };

      const output: string[] = [
        `# Vulnerability Search: "${query}"`,
        '',
        `Found ${data.totalResults || 0} results`,
        '',
        '| CVE ID | Severity | Score | Description |',
        '|--------|----------|-------|-------------|',
      ];

      for (const vuln of data.vulnerabilities || []) {
        const cve = vuln.cve;
        if (!cve) continue;

        const cvss = cve.metrics?.cvssMetricV31?.[0]?.cvssData;
        const desc =
          cve.descriptions?.find((d) => d.lang === 'en')?.value || '';
        const shortDesc =
          desc.length > 60 ? desc.substring(0, 60) + '...' : desc;

        output.push(
          `| ${cve.id} | ${cvss?.baseSeverity || 'N/A'} | ${cvss?.baseScore || 'N/A'} | ${shortDesc} |`,
        );
      }

      return {
        llmContent: output.join('\n'),
        returnDisplay: `Found ${data.totalResults || 0} CVEs`,
      };
    } catch {
      return this.searchKnownVulnerabilities(query, severity);
    }
  }

  /**
   * Search known vulnerabilities (fallback)
   */
  private searchKnownVulnerabilities(
    query: string,
    severity?: string,
  ): ToolResult {
    const allCVEs = [
      {
        id: 'CVE-2021-44228',
        severity: 'CRITICAL',
        score: 10.0,
        desc: 'Log4j RCE (Log4Shell)',
      },
      {
        id: 'CVE-2017-0144',
        severity: 'CRITICAL',
        score: 8.1,
        desc: 'Windows SMB RCE (EternalBlue)',
      },
      {
        id: 'CVE-2021-34527',
        severity: 'HIGH',
        score: 8.8,
        desc: 'Windows Print Spooler RCE (PrintNightmare)',
      },
      {
        id: 'CVE-2023-44487',
        severity: 'HIGH',
        score: 7.5,
        desc: 'HTTP/2 Rapid Reset Attack',
      },
      {
        id: 'CVE-2024-3094',
        severity: 'CRITICAL',
        score: 10.0,
        desc: 'XZ Utils Backdoor',
      },
      {
        id: 'CVE-2021-26855',
        severity: 'CRITICAL',
        score: 9.8,
        desc: 'Microsoft Exchange ProxyLogon',
      },
      {
        id: 'CVE-2021-27065',
        severity: 'HIGH',
        score: 7.8,
        desc: 'Microsoft Exchange ProxyLogon',
      },
      {
        id: 'CVE-2019-19781',
        severity: 'CRITICAL',
        score: 9.8,
        desc: 'Citrix ADC Path Traversal',
      },
      {
        id: 'CVE-2020-1472',
        severity: 'CRITICAL',
        score: 10.0,
        desc: 'Zerologon - Netlogon Privilege Escalation',
      },
      {
        id: 'CVE-2021-21972',
        severity: 'CRITICAL',
        score: 9.8,
        desc: 'VMware vCenter Server RCE',
      },
      {
        id: 'CVE-2022-22965',
        severity: 'CRITICAL',
        score: 9.8,
        desc: 'Spring4Shell RCE',
      },
      {
        id: 'CVE-2023-23397',
        severity: 'CRITICAL',
        score: 9.8,
        desc: 'Microsoft Outlook Privilege Escalation',
      },
      {
        id: 'CVE-2023-34362',
        severity: 'CRITICAL',
        score: 9.8,
        desc: 'MOVEit Transfer SQL Injection',
      },
    ];

    const lowerQuery = query.toLowerCase();
    let filtered = allCVEs.filter(
      (c) =>
        c.id.toLowerCase().includes(lowerQuery) ||
        c.desc.toLowerCase().includes(lowerQuery),
    );

    if (severity) {
      filtered = filtered.filter(
        (c) => c.severity.toLowerCase() === severity.toLowerCase(),
      );
    }

    const output: string[] = [
      `# Vulnerability Search: "${query}"`,
      '',
      `Found ${filtered.length} results (cached data)`,
      '',
      '| CVE ID | Severity | Score | Description |',
      '|--------|----------|-------|-------------|',
    ];

    for (const cve of filtered) {
      output.push(
        `| ${cve.id} | ${cve.severity} | ${cve.score} | ${cve.desc} |`,
      );
    }

    return {
      llmContent: output.join('\n'),
      returnDisplay: `Found ${filtered.length} CVEs`,
    };
  }

  /**
   * Search Exploit-DB
   */
  private async searchExploits(): Promise<ToolResult> {
    const { query, cveId, limit = 10 } = this.params;
    const searchTerm = query || cveId;

    if (!searchTerm) {
      return {
        llmContent: 'Search query or CVE ID is required',
        returnDisplay: 'Missing search term',
        error: {
          message: 'Search query or CVE ID is required',
          type: ToolErrorType.INVALID_TOOL_PARAMS,
        },
      };
    }

    const exploits = cveId
      ? await this.fetchExploitDBData(cveId)
      : this.getKnownExploitsByKeyword(searchTerm);

    if (exploits.length === 0) {
      return {
        llmContent: `No exploits found for: ${searchTerm}`,
        returnDisplay: 'No exploits found',
      };
    }

    const output: string[] = [
      `# Exploit Search: "${searchTerm}"`,
      '',
      `Found ${exploits.length} exploits`,
      '',
    ];

    for (const exploit of exploits.slice(0, limit)) {
      output.push(`## ${exploit.title}`);
      output.push('');
      output.push(`- **ID:** ${exploit.id}`);
      output.push(`- **Platform:** ${exploit.platform}`);
      output.push(`- **Type:** ${exploit.type}`);
      output.push(`- **Author:** ${exploit.author}`);
      output.push(`- **Date:** ${exploit.date}`);
      output.push(`- **Verified:** ${exploit.verified ? 'âœ…' : 'âŒ'}`);
      output.push(`- **URL:** ${exploit.url}`);
      if (exploit.cve) {
        output.push(`- **CVE:** ${exploit.cve}`);
      }
      output.push('');
    }

    return {
      llmContent: output.join('\n'),
      returnDisplay: `Found ${exploits.length} exploits`,
    };
  }

  /**
   * Get known exploits by keyword
   */
  private getKnownExploitsByKeyword(keyword: string): ExploitData[] {
    const allExploits: ExploitData[] = [
      {
        id: '50592',
        title: 'Apache Log4j 2 - Remote Code Execution (RCE)',
        platform: 'Multiple',
        type: 'Remote',
        author: 'Various',
        date: '2021-12-10',
        url: 'https://www.exploit-db.com/exploits/50592',
        cve: 'CVE-2021-44228',
        verified: true,
      },
      {
        id: '42315',
        title: 'Microsoft Windows - SMB Remote Code Execution (EternalBlue)',
        platform: 'Windows',
        type: 'Remote',
        author: 'Shadow Brokers',
        date: '2017-05-17',
        url: 'https://www.exploit-db.com/exploits/42315',
        cve: 'CVE-2017-0144',
        verified: true,
      },
      {
        id: '50055',
        title: 'Windows Print Spooler - Remote Code Execution (PrintNightmare)',
        platform: 'Windows',
        type: 'Remote',
        author: 'Various',
        date: '2021-07-01',
        url: 'https://www.exploit-db.com/exploits/50055',
        cve: 'CVE-2021-34527',
        verified: true,
      },
      {
        id: '49637',
        title: 'Microsoft Exchange - ProxyLogon Remote Code Execution',
        platform: 'Windows',
        type: 'Remote',
        author: 'Various',
        date: '2021-03-11',
        url: 'https://www.exploit-db.com/exploits/49637',
        cve: 'CVE-2021-26855',
        verified: true,
      },
      {
        id: '49071',
        title: 'Zerologon - Windows Netlogon Privilege Escalation',
        platform: 'Windows',
        type: 'Local',
        author: 'Secura',
        date: '2020-09-14',
        url: 'https://www.exploit-db.com/exploits/49071',
        cve: 'CVE-2020-1472',
        verified: true,
      },
    ];

    const lower = keyword.toLowerCase();
    return allExploits.filter(
      (e) =>
        e.title.toLowerCase().includes(lower) ||
        e.cve?.toLowerCase().includes(lower) ||
        e.platform.toLowerCase().includes(lower),
    );
  }

  /**
   * Check for public PoCs
   */
  private async checkPoCs(): Promise<ToolResult> {
    const { cveId } = this.params;

    if (!cveId) {
      return {
        llmContent: 'CVE ID is required',
        returnDisplay: 'Missing CVE ID',
        error: {
          message: 'CVE ID is required',
          type: ToolErrorType.INVALID_TOOL_PARAMS,
        },
      };
    }

    const pocs = await this.checkGitHubPoCs(cveId);
    const exploits = await this.fetchExploitDBData(cveId);

    const output: string[] = [`# PoC Check: ${cveId}`, ''];

    if (pocs.length > 0) {
      output.push('## GitHub Repositories');
      output.push('');
      for (const poc of pocs) {
        output.push(`- [${poc.name}](${poc.url}) â­ ${poc.stars}`);
      }
      output.push('');
    } else {
      output.push('## GitHub Repositories');
      output.push('');
      output.push('No PoC repositories found on GitHub.');
      output.push('');
    }

    if (exploits.length > 0) {
      output.push('## Exploit-DB');
      output.push('');
      for (const exploit of exploits) {
        output.push(
          `- [${exploit.title}](${exploit.url}) ${exploit.verified ? 'âœ… Verified' : ''}`,
        );
      }
      output.push('');
    } else {
      output.push('## Exploit-DB');
      output.push('');
      output.push('No exploits found on Exploit-DB.');
      output.push('');
    }

    output.push('## Additional Resources');
    output.push('');
    output.push(`- [NVD Entry](https://nvd.nist.gov/vuln/detail/${cveId})`);
    output.push(
      `- [MITRE Entry](https://cve.mitre.org/cgi-bin/cvename.cgi?name=${cveId})`,
    );
    output.push(
      `- [GitHub Code Search](https://github.com/search?q=${cveId}&type=code)`,
    );

    return {
      llmContent: output.join('\n'),
      returnDisplay: `PoCs for ${cveId}`,
    };
  }

  /**
   * Search by product/vendor
   */
  private async searchByProduct(): Promise<ToolResult> {
    const { product, vendor, limit = 20 } = this.params;

    if (!product && !vendor) {
      return {
        llmContent: 'Product or vendor name is required',
        returnDisplay: 'Missing product/vendor',
        error: {
          message: 'Product or vendor name is required',
          type: ToolErrorType.INVALID_TOOL_PARAMS,
        },
      };
    }

    const searchTerm = product || vendor || '';

    try {
      const nvdApiKey = apiKeyManager.getApiKey('nvd');
      const headers: Record<string, string> = { Accept: 'application/json' };
      if (nvdApiKey) {
        headers['apiKey'] = nvdApiKey;
      }

      const url = `https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=${encodeURIComponent(searchTerm)}&resultsPerPage=${limit}`;
      const response = await fetch(url, { headers });

      if (!response.ok) {
        throw new Error(`NVD API error: ${response.status}`);
      }

      const data = (await response.json()) as {
        totalResults?: number;
        vulnerabilities?: Array<{
          cve?: {
            id?: string;
            descriptions?: Array<{ lang?: string; value?: string }>;
            metrics?: {
              cvssMetricV31?: Array<{
                cvssData?: { baseScore?: number; baseSeverity?: string };
              }>;
            };
          };
        }>;
      };

      const output: string[] = [
        `# Vulnerabilities for: ${searchTerm}`,
        '',
        `Total: ${data.totalResults || 0} vulnerabilities`,
        '',
        '| CVE ID | Severity | Score | Description |',
        '|--------|----------|-------|-------------|',
      ];

      for (const vuln of data.vulnerabilities || []) {
        const cve = vuln.cve;
        if (!cve) continue;

        const cvss = cve.metrics?.cvssMetricV31?.[0]?.cvssData;
        const desc =
          cve.descriptions?.find((d) => d.lang === 'en')?.value || '';
        const shortDesc =
          desc.length > 50 ? desc.substring(0, 50) + '...' : desc;

        output.push(
          `| ${cve.id} | ${cvss?.baseSeverity || 'N/A'} | ${cvss?.baseScore || 'N/A'} | ${shortDesc} |`,
        );
      }

      return {
        llmContent: output.join('\n'),
        returnDisplay: `${data.totalResults || 0} CVEs for ${searchTerm}`,
      };
    } catch {
      return this.searchKnownVulnerabilities(searchTerm);
    }
  }

  /**
   * Get recent CVEs
   */
  private async getRecentCVEs(): Promise<ToolResult> {
    const { limit = 20, severity } = this.params;

    try {
      const nvdApiKey = apiKeyManager.getApiKey('nvd');
      const headers: Record<string, string> = { Accept: 'application/json' };
      if (nvdApiKey) {
        headers['apiKey'] = nvdApiKey;
      }

      // Get CVEs from the last 7 days
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(startDate.getDate() - 7);

      let url = `https://services.nvd.nist.gov/rest/json/cves/2.0?pubStartDate=${startDate.toISOString()}&pubEndDate=${endDate.toISOString()}&resultsPerPage=${limit}`;

      if (severity) {
        url += `&cvssV3Severity=${severity.toUpperCase()}`;
      }

      const response = await fetch(url, { headers });

      if (!response.ok) {
        throw new Error(`NVD API error: ${response.status}`);
      }

      const data = (await response.json()) as {
        totalResults?: number;
        vulnerabilities?: Array<{
          cve?: {
            id?: string;
            descriptions?: Array<{ lang?: string; value?: string }>;
            metrics?: {
              cvssMetricV31?: Array<{
                cvssData?: { baseScore?: number; baseSeverity?: string };
              }>;
            };
            published?: string;
          };
        }>;
      };

      const output: string[] = [
        '# Recent CVEs (Last 7 Days)',
        '',
        `Total: ${data.totalResults || 0} new vulnerabilities`,
        '',
        '| CVE ID | Severity | Score | Published | Description |',
        '|--------|----------|-------|-----------|-------------|',
      ];

      for (const vuln of data.vulnerabilities || []) {
        const cve = vuln.cve;
        if (!cve) continue;

        const cvss = cve.metrics?.cvssMetricV31?.[0]?.cvssData;
        const desc =
          cve.descriptions?.find((d) => d.lang === 'en')?.value || '';
        const shortDesc =
          desc.length > 40 ? desc.substring(0, 40) + '...' : desc;
        const pubDate = cve.published
          ? new Date(cve.published).toLocaleDateString()
          : 'N/A';

        output.push(
          `| ${cve.id} | ${cvss?.baseSeverity || 'N/A'} | ${cvss?.baseScore || 'N/A'} | ${pubDate} | ${shortDesc} |`,
        );
      }

      return {
        llmContent: output.join('\n'),
        returnDisplay: `${data.totalResults || 0} recent CVEs`,
      };
    } catch {
      return {
        llmContent:
          'Unable to fetch recent CVEs. NVD API may be rate limited. Try again later.',
        returnDisplay: 'API error',
      };
    }
  }

  /**
   * Search by severity
   */
  private async searchBySeverity(): Promise<ToolResult> {
    const { severity } = this.params;

    if (!severity) {
      return {
        llmContent: 'Severity level is required (low, medium, high, critical)',
        returnDisplay: 'Missing severity',
        error: {
          message: 'Severity level is required',
          type: ToolErrorType.INVALID_TOOL_PARAMS,
        },
      };
    }

    return this.searchVulnerabilities();
  }

  /**
   * Get CWE details
   */
  private getCWEDetails(): ToolResult {
    const { cweId } = this.params;

    if (!cweId) {
      return {
        llmContent: 'CWE ID is required',
        returnDisplay: 'Missing CWE ID',
        error: {
          message: 'CWE ID is required',
          type: ToolErrorType.INVALID_TOOL_PARAMS,
        },
      };
    }

    const normalizedCweId = cweId.toUpperCase().replace('CWE-', '');

    const cweData: Record<
      string,
      { name: string; description: string; mitigations: string[] }
    > = {
      '79': {
        name: 'Improper Neutralization of Input During Web Page Generation (XSS)',
        description:
          'The software does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page.',
        mitigations: [
          'Use context-aware output encoding',
          'Implement Content Security Policy (CSP)',
          'Validate and sanitize all user input',
          'Use templating engines with auto-escaping',
        ],
      },
      '89': {
        name: 'Improper Neutralization of Special Elements used in an SQL Command (SQL Injection)',
        description:
          'The software constructs all or part of an SQL command using externally-influenced input, but does not neutralize special elements that could modify the intended SQL command.',
        mitigations: [
          'Use parameterized queries/prepared statements',
          'Use stored procedures',
          'Escape all user input',
          'Apply least privilege to database accounts',
        ],
      },
      '22': {
        name: 'Improper Limitation of a Pathname to a Restricted Directory (Path Traversal)',
        description:
          'The software uses external input to construct a pathname but does not properly neutralize sequences like ".." that could resolve to a location outside the restricted directory.',
        mitigations: [
          'Validate and sanitize file paths',
          'Use a whitelist of allowed files/directories',
          'Canonicalize paths before validation',
          'Run with minimal privileges',
        ],
      },
      '78': {
        name: 'Improper Neutralization of Special Elements used in an OS Command (Command Injection)',
        description:
          'The software constructs all or part of an OS command using externally-influenced input but does not neutralize special elements that could modify the intended command.',
        mitigations: [
          'Avoid calling OS commands directly',
          'Use language-specific APIs instead of shell commands',
          'Escape all user input',
          'Use allowlists for permitted characters',
        ],
      },
      '287': {
        name: 'Improper Authentication',
        description:
          'When an actor claims to have a given identity, the software does not prove or insufficiently proves that the claim is correct.',
        mitigations: [
          'Implement multi-factor authentication',
          'Use strong password policies',
          'Implement account lockout mechanisms',
          'Use secure session management',
        ],
      },
      '502': {
        name: 'Deserialization of Untrusted Data',
        description:
          'The application deserializes untrusted data without sufficiently verifying that the resulting data will be valid.',
        mitigations: [
          'Avoid deserializing untrusted data',
          'Use digital signatures to verify integrity',
          'Restrict deserialization to specific classes',
          'Implement integrity checks',
        ],
      },
      '918': {
        name: 'Server-Side Request Forgery (SSRF)',
        description:
          'The web server receives a URL or similar request from an upstream component and retrieves the contents of this URL, but it does not sufficiently ensure that the request is being sent to the expected destination.',
        mitigations: [
          'Validate and sanitize URLs',
          'Use allowlists for permitted domains',
          'Disable unnecessary URL schemes',
          'Implement network segmentation',
        ],
      },
    };

    const cwe = cweData[normalizedCweId];

    if (!cwe) {
      return {
        llmContent: `CWE-${normalizedCweId} not found in local database. Visit https://cwe.mitre.org/data/definitions/${normalizedCweId}.html for details.`,
        returnDisplay: `CWE-${normalizedCweId}`,
      };
    }

    const output: string[] = [
      `# CWE-${normalizedCweId}`,
      '',
      `**${cwe.name}**`,
      '',
      '## Description',
      '',
      cwe.description,
      '',
      '## Mitigations',
      '',
      ...cwe.mitigations.map((m) => `- ${m}`),
      '',
      '## References',
      '',
      `- [MITRE CWE Entry](https://cwe.mitre.org/data/definitions/${normalizedCweId}.html)`,
      `- [OWASP](https://owasp.org/)`,
    ];

    return {
      llmContent: output.join('\n'),
      returnDisplay: `CWE-${normalizedCweId}`,
    };
  }
}

/**
 * Tool schema
 */
const VULN_DB_SCHEMA = {
  type: 'object',
  properties: {
    operation: {
      type: 'string',
      enum: [
        'cve',
        'search',
        'exploit',
        'poc',
        'product',
        'recent',
        'severity',
        'cwe',
      ],
      description: `Operation to perform:
- cve: Get detailed CVE information
- search: Search vulnerabilities by keyword
- exploit: Search Exploit-DB
- poc: Check for public PoCs
- product: Search by product/vendor
- recent: Get recent CVEs
- severity: Search by severity level
- cwe: Get CWE weakness details`,
    },
    cveId: {
      type: 'string',
      description: 'CVE identifier (e.g., CVE-2021-44228)',
    },
    query: {
      type: 'string',
      description: 'Search query for vulnerabilities',
    },
    product: {
      type: 'string',
      description: 'Product name to search',
    },
    vendor: {
      type: 'string',
      description: 'Vendor name to search',
    },
    severity: {
      type: 'string',
      enum: ['low', 'medium', 'high', 'critical'],
      description: 'Filter by severity level',
    },
    cweId: {
      type: 'string',
      description: 'CWE identifier (e.g., CWE-79)',
    },
    limit: {
      type: 'number',
      description: 'Maximum number of results (default: 10)',
    },
    includeExploits: {
      type: 'boolean',
      description: 'Include exploit information (default: true)',
    },
  },
  required: ['operation'],
};

/**
 * Vulnerability Database Tool
 */
export class VulnDbTool extends BaseDeclarativeTool<VulnDbParams, ToolResult> {
  static readonly Name: string = ToolNames.VULN_DB;

  constructor() {
    super(
      ToolNames.VULN_DB,
      ToolDisplayNames.VULN_DB,
      `Query vulnerability databases (NVD, Exploit-DB) for CVE details, exploits, and PoCs.

Examples:
1. Get CVE details: { "operation": "cve", "cveId": "CVE-2021-44228" }
2. Search vulns: { "operation": "search", "query": "apache log4j" }
3. Find exploits: { "operation": "exploit", "cveId": "CVE-2021-44228" }
4. Check PoCs: { "operation": "poc", "cveId": "CVE-2021-44228" }
5. Search by product: { "operation": "product", "product": "wordpress" }
6. Recent CVEs: { "operation": "recent", "severity": "critical" }
7. CWE details: { "operation": "cwe", "cweId": "CWE-79" }`,
      Kind.Read,
      VULN_DB_SCHEMA,
      true,
    );
  }

  override validateToolParamValues(params: VulnDbParams): string | null {
    const { operation, cveId, query, product, vendor, cweId } = params;

    if (operation === 'cve' && !cveId) {
      return 'CVE ID is required for cve operation';
    }

    if (operation === 'search' && !query) {
      return 'Search query is required for search operation';
    }

    if (operation === 'exploit' && !query && !cveId) {
      return 'Query or CVE ID is required for exploit operation';
    }

    if (operation === 'poc' && !cveId) {
      return 'CVE ID is required for poc operation';
    }

    if (operation === 'product' && !product && !vendor) {
      return 'Product or vendor name is required';
    }

    if (operation === 'cwe' && !cweId) {
      return 'CWE ID is required for cwe operation';
    }

    return null;
  }

  protected override createInvocation(
    params: VulnDbParams,
  ): ToolInvocation<VulnDbParams, ToolResult> {
    return new VulnDbInvocation(params);
  }
}
